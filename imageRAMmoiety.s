
	.segment "IMAGE"
	.export	sprites
	.export	spritescroller
	.export	imagecolours
	.export	imagebitmap
	.export	spritepointer
	.export	whiteout_screen
	.export	whiteout_colour
	.export copy_image2screen
	.export colourin_screen
	.export colourin_via_lfsr
	.export whiteout_via_lfsr
	.export	colourin_whole_screen
	.export whiteout_whole_screen
	.export screen4col
	.export screen0
	.export fill_screenram
	.export	fill_colourram

	.macpack	generic
	.import	wait_single_frame

	.segment "IMAGE"
sprites:
;;; The zero byte fills the sprite up to 64 bytes so that they are correctly aligned.
;;; Generated by SpriteMate by Awsm.
;; sprite 0 / singlecolor / color: $07
sprite_0:
	.byte %00000000,%01111100,%00000000
	.byte %00000001,%11111111,%00000000
	.byte %00000111,%11111111,%11000000
	.byte %00001111,%11111111,%11100000
	.byte %00011111,%11111111,%11110000
	.byte %00011111,%11111111,%11110000
	.byte %00111111,%11111111,%11111000
	.byte %00111111,%11111111,%11111000
	.byte %01111111,%11111111,%11111100
	.byte %01111111,%11111111,%11111100
	.byte %01111111,%11100000,%00000000
	.byte %01111111,%11111111,%11111100
	.byte %01111111,%11111111,%11111100
	.byte %00111111,%11111111,%11111000
	.byte %00111111,%11111111,%11111000
	.byte %00011111,%11111111,%11110000
	.byte %00011111,%11111111,%11110000
	.byte %00001111,%11111111,%11100000
	.byte %00000111,%11111111,%11000000
	.byte %00000001,%11111111,%00000000
	.byte %00000000,%01111100,%00000000
	.byte	0
;; sprite 1 / singlecolor / color: $07
sprite_1:
	.byte %00000000,%01111100,%00000000
	.byte %00000001,%11111111,%00000000
	.byte %00000111,%11111111,%11000000
	.byte %00001111,%11111111,%11100000
	.byte %00011111,%11111111,%11110000
	.byte %00011111,%11111111,%11110000
	.byte %00111111,%11111111,%11100000
	.byte %00111111,%11111111,%10000000
	.byte %01111111,%11111110,%00000000
	.byte %01111111,%11111000,%00000000
	.byte %01111111,%11100000,%00000000
	.byte %01111111,%11111000,%00000000
	.byte %01111111,%11111110,%00000000
	.byte %00111111,%11111111,%10000000
	.byte %00111111,%11111111,%11100000
	.byte %00011111,%11111111,%11110000
	.byte %00011111,%11111111,%11110000
	.byte %00001111,%11111111,%11100000
	.byte %00000111,%11111111,%11000000
	.byte %00000001,%11111111,%00000000
	.byte %00000000,%01111100,%00000000
	.byte	0
;; sprite 2 / singlecolor / color: $07
sprite_2:
	.byte %00000000,%01111100,%00000000
	.byte %00000001,%11111111,%00000000
	.byte %00000111,%11111111,%11000000
	.byte %00001111,%11111111,%11000000
	.byte %00011111,%11111111,%10000000
	.byte %00011111,%11111111,%00000000
	.byte %00111111,%11111110,%00000000
	.byte %00111111,%11111100,%00000000
	.byte %01111111,%11111000,%00000000
	.byte %01111111,%11110000,%00000000
	.byte %01111111,%11100000,%00000000
	.byte %01111111,%11110000,%00000000
	.byte %01111111,%11111000,%00000000
	.byte %00111111,%11111100,%00000000
	.byte %00111111,%11111110,%00000000
	.byte %00011111,%11111111,%00000000
	.byte %00011111,%11111111,%10000000
	.byte %00001111,%11111111,%11000000
	.byte %00000111,%11111111,%11000000
	.byte %00000001,%11111111,%00000000
	.byte %00000000,%01111100,%00000000
	.byte	0
;; sprite 3 / singlecolor / color: $07
sprite_3:
	.byte %00000000,%01111100,%00000000
	.byte %00000001,%11111111,%00000000
	.byte %00000111,%11111111,%11000000
	.byte %00001111,%11111111,%11100000
	.byte %00011111,%11111111,%11110000
	.byte %00011111,%11111111,%11110000
	.byte %00111111,%11111111,%11100000
	.byte %00111111,%11111111,%10000000
	.byte %01111111,%11111110,%00000000
	.byte %01111111,%11111000,%00000000
	.byte %01111111,%11100000,%00000000
	.byte %01111111,%11111000,%00000000
	.byte %01111111,%11111110,%00000000
	.byte %00111111,%11111111,%10000000
	.byte %00111111,%11111111,%11100000
	.byte %00011111,%11111111,%11110000
	.byte %00011111,%11111111,%11110000
	.byte %00001111,%11111111,%11100000
	.byte %00000111,%11111111,%11000000
	.byte %00000001,%11111111,%00000000
	.byte %00000000,%01111100,%00000000
	.byte	0


ghostsprite_0:
	.byte $01, $FE, $00 
	.byte $0F, $FF, $80 
	.byte $1F, $FF, $C0 
	.byte $7F, $FF, $F0 
	.byte $FF, $FF, $F8 
	.byte $FC, $71, $F8 
	.byte $FC, $71, $F8 
	.byte $FC, $71, $F8 
	.byte $FC, $71, $F8 
	.byte $FF, $FF, $F8 
	.byte $FF, $FF, $F8 
	.byte $FE, $FE, $78 
	.byte $F8, $1C, $F8 
	.byte $F3, $81, $F8 
	.byte $F3, $E1, $F8 
	.byte $F7, $FF, $F8 
	.byte $FF, $EF, $F0 
	.byte $DD, $EE, $70 
	.byte $8C, $C6, $60 
	.byte $88, $44, $20 
	.byte $88, $44, $20 
	.byte $81
ghostsprite_1:
	.byte $01, $FE, $00 
	.byte $0F, $FF, $80 
	.byte $1F, $FF, $C0 
	.byte $7F, $FF, $F0 
	.byte $FF, $FF, $F8 
	.byte $FC, $71, $F8 
	.byte $FC, $71, $F8 
	.byte $FC, $71, $F8 
	.byte $FC, $71, $F8 
	.byte $FF, $FF, $F8 
	.byte $FF, $FF, $F8 
	.byte $FE, $FE, $78 
	.byte $F8, $1C, $F8 
	.byte $F3, $81, $F8 
	.byte $F3, $E1, $F8 
	.byte $F7, $FF, $F8 
	.byte $FF, $EF, $F0 
	.byte $DD, $EE, $70 
	.byte $4C, $C6, $60 
	.byte $44, $82, $40 
	.byte $44, $82, $40 
	.byte $81

	.byte $01, $FE, $00 
	.byte $0F, $FF, $80 
	.byte $1F, $FF, $C0 
	.byte $7F, $FF, $F0 
	.byte $FF, $FF, $F8 
	.byte $FE, $38, $F8 
	.byte $FE, $38, $F8 
	.byte $FE, $38, $F8 
	.byte $FE, $38, $F8 
	.byte $FF, $FF, $F8 
	.byte $FF, $FF, $F8 
	.byte $FE, $FE, $78 
	.byte $F8, $1C, $F8 
	.byte $F3, $81, $F8 
	.byte $F3, $E1, $F8 
	.byte $F7, $FF, $F8 
	.byte $FF, $EF, $F0 
	.byte $DD, $EE, $70 
	.byte $8C, $C6, $60 
	.byte $88, $44, $20 
	.byte $88, $44, $20 
	.byte $81
	;; spriteconv -x 72 ghost.gif 
	.byte $01, $FE, $00 
	.byte $0F, $FF, $80 
	.byte $1F, $FF, $C0 
	.byte $7F, $FF, $F0 
	.byte $FF, $FF, $F8 
	.byte $FE, $38, $F8 
	.byte $FE, $38, $F8 
	.byte $FE, $38, $F8 
	.byte $FE, $38, $F8 
	.byte $FF, $FF, $F8 
	.byte $FF, $FF, $F8 
	.byte $FE, $FE, $78 
	.byte $F8, $1C, $F8 
	.byte $F3, $81, $F8 
	.byte $F3, $E1, $F8 
	.byte $F7, $FF, $F8 
	.byte $FF, $EF, $F0 
	.byte $DD, $EE, $70 
	.byte $4C, $C6, $60 
	.byte $44, $82, $40 
	.byte $44, $82, $40 
	.byte $81

spritescroller:
	.res	64*8		; 512
screen0:
	.res	1024
screen4col:			; Screen with colours for the hires bitmap in the later stages.
	.res	1000		; 40*25
	.res	16		; Empty space
spritepointer:
	.res	8
imagecolours:
	;; Screen Ram, positioned in the file after the 8000 bytes of the bitmap.
	.incbin	"helloscreen.c64",8000,1000
	.res	24		; Empty space
imagebitmap:
	;; Here comes the bitmap, the first 8000 bytes of the file.
	.incbin	"helloscreen.c64",0,8000

	.data
whiteout_colour:		; This is the colour value to use for the "whiteout_*" functions.
	.byte	$ff

	.code
;;; Whiteout the screen (only a single step). The screen colours (hires bitmap) are shaded away, starting left and right. After being called 20 times the screen is filled with white. 
whiteout_screen:
	lda	whiteout_colour
	jmp	colourout_screen
;;; Colourout the screen (only a single step). The screen colours (hires bitmap) are shaded away, starting left and right. After being called 20 times the screen is filled with white.
;;; Input: A=colour to fill the screen with
;;; Output:
;;; Modifies: A/X/Y
colourout_screen:
	pha
	lda	_whiteout_pos
	tax
	;; 40-A-1 = -(A+1-40)
	sub	#39
	eor	#$ff		; Negate
	add	#1
	tay
	pla
	sta	screen4col+40*00,x
	sta	screen4col+40*00,y
	sta	screen4col+40*01,x
	sta	screen4col+40*01,y
	sta	screen4col+40*02,x
	sta	screen4col+40*02,y
	sta	screen4col+40*03,x
	sta	screen4col+40*03,y
	sta	screen4col+40*04,x
	sta	screen4col+40*04,y
	sta	screen4col+40*05,x
	sta	screen4col+40*05,y
	sta	screen4col+40*06,x
	sta	screen4col+40*06,y
	sta	screen4col+40*07,x
	sta	screen4col+40*07,y
	sta	screen4col+40*08,x
	sta	screen4col+40*08,y
	sta	screen4col+40*09,x
	sta	screen4col+40*09,y
	sta	screen4col+40*10,x
	sta	screen4col+40*10,y
	sta	screen4col+40*11,x
	sta	screen4col+40*11,y
	sta	screen4col+40*12,x
	sta	screen4col+40*12,y
	sta	screen4col+40*13,x
	sta	screen4col+40*13,y
	sta	screen4col+40*14,x
	sta	screen4col+40*14,y
	sta	screen4col+40*15,x
	sta	screen4col+40*15,y
	sta	screen4col+40*16,x
	sta	screen4col+40*16,y
	sta	screen4col+40*17,x
	sta	screen4col+40*17,y
	sta	screen4col+40*18,x
	sta	screen4col+40*18,y
	sta	screen4col+40*19,x
	sta	screen4col+40*19,y
	sta	screen4col+40*20,x
	sta	screen4col+40*20,y
	sta	screen4col+40*21,x
	sta	screen4col+40*21,y
	sta	screen4col+40*22,x
	sta	screen4col+40*22,y
	sta	screen4col+40*23,x
	sta	screen4col+40*23,y
	sta	screen4col+40*24,x
	sta	screen4col+40*24,y
	;; Loop missing
	dec	_whiteout_pos
	dec	_whiteout_pos
	bpl	@out
	lda	#39
	sta	_whiteout_pos
	@out:
	rts

;;; Copy the uncrunched colour information to the active screen ram.
;;; Modifies: A/X/Y
colourin_screen:
	lda	_whiteout_pos
	tax
	;; 40-A-1 = -(A+1-40)
	sub	#39
	eor	#$ff		; Negate
	add	#1
	tay
 	lda	imagecolours+40*0,x
	sta	screen4col+40*0,x
	lda	imagecolours+40*0,y
	sta	screen4col+40*0,y
	lda	imagecolours+40*1,x
	sta	screen4col+40*1,x
	lda	imagecolours+40*1,y
	sta	screen4col+40*1,y
	lda	imagecolours+40*2,x
	sta	screen4col+40*2,x
	lda	imagecolours+40*2,y
	sta	screen4col+40*2,y
	lda	imagecolours+40*3,x
	sta	screen4col+40*3,x
	lda	imagecolours+40*3,y
	sta	screen4col+40*3,y
	lda	imagecolours+40*4,x
	sta	screen4col+40*4,x
	lda	imagecolours+40*4,y
	sta	screen4col+40*4,y
	lda	imagecolours+40*5,x
	sta	screen4col+40*5,x
	lda	imagecolours+40*5,y
	sta	screen4col+40*5,y
	lda	imagecolours+40*6,x
	sta	screen4col+40*6,x
	lda	imagecolours+40*6,y
	sta	screen4col+40*6,y
	lda	imagecolours+40*7,x
	sta	screen4col+40*7,x
	lda	imagecolours+40*7,y
	sta	screen4col+40*7,y
	lda	imagecolours+40*8,x
	sta	screen4col+40*8,x
	lda	imagecolours+40*8,y
	sta	screen4col+40*8,y
	lda	imagecolours+40*9,x
	sta	screen4col+40*9,x
	lda	imagecolours+40*9,y
	sta	screen4col+40*9,y
	lda	imagecolours+40*10,x
	sta	screen4col+40*10,x
	lda	imagecolours+40*10,y
	sta	screen4col+40*10,y
	lda	imagecolours+40*11,x
	sta	screen4col+40*11,x
	lda	imagecolours+40*11,y
	sta	screen4col+40*11,y
	lda	imagecolours+40*12,x
	sta	screen4col+40*12,x
	lda	imagecolours+40*12,y
	sta	screen4col+40*12,y
	lda	imagecolours+40*13,x
	sta	screen4col+40*13,x
	lda	imagecolours+40*13,y
	sta	screen4col+40*13,y
	lda	imagecolours+40*14,x
	sta	screen4col+40*14,x
	lda	imagecolours+40*14,y
	sta	screen4col+40*14,y
	lda	imagecolours+40*15,x
	sta	screen4col+40*15,x
	lda	imagecolours+40*15,y
	sta	screen4col+40*15,y
	lda	imagecolours+40*16,x
	sta	screen4col+40*16,x
	lda	imagecolours+40*16,y
	sta	screen4col+40*16,y
	lda	imagecolours+40*17,x
	sta	screen4col+40*17,x
	lda	imagecolours+40*17,y
	sta	screen4col+40*17,y
	lda	imagecolours+40*18,x
	sta	screen4col+40*18,x
	lda	imagecolours+40*18,y
	sta	screen4col+40*18,y
	lda	imagecolours+40*19,x
	sta	screen4col+40*19,x
	lda	imagecolours+40*19,y
	sta	screen4col+40*19,y
	lda	imagecolours+40*20,x
	sta	screen4col+40*20,x
	lda	imagecolours+40*20,y
	sta	screen4col+40*20,y
	lda	imagecolours+40*21,x
	sta	screen4col+40*21,x
	lda	imagecolours+40*21,y
	sta	screen4col+40*21,y
	lda	imagecolours+40*22,x
	sta	screen4col+40*22,x
	lda	imagecolours+40*22,y
	sta	screen4col+40*22,y
	lda	imagecolours+40*23,x
	sta	screen4col+40*23,x
	lda	imagecolours+40*23,y
	sta	screen4col+40*23,y
	lda	imagecolours+40*24,x
	sta	screen4col+40*24,x
	lda	imagecolours+40*24,y
	sta	screen4col+40*24,y
	dec	_whiteout_pos
	dec	_whiteout_pos
	bpl	@out
	lda	#39
	sta	_whiteout_pos
	@out:
	rts

	.data
_whiteout_pos:	.byte	39


	.code
;;; Copy the image data to the screen ram.
copy_image2screen:
	ldx	#0
	@l1:
	lda	imagecolours,x
	sta	screen4col,x
	lda	imagecolours+$100,x
	sta	screen4col+$100,x
	lda	imagecolours+$200,x
	sta	screen4col+$200,x
	inx
	bne	@l1
	ldx	#$f7
	@l2:
	lda	imagecolours+$300,x
	sta	screen4col+$300,x
	dex
	bne	@l2
	lda	imagecolours+$300
	sta	screen4col+$300
	rts

whiteout_via_lfsr:
	lda	#$a9
	sta	whiteout_via_lfsr_state
@loop:	jsr	@advance
	jsr	@store
	lda	whiteout_via_lfsr_state
	cmp	#$a9		; At the beginning?
	beq	@out
	jsr	@advance
	jsr	@store
	lda	whiteout_via_lfsr_state
	cmp	#$a9		; At the beginning?
	beq	@out
	jsr	@advance
	jsr	@store
	jsr	wait_single_frame
	lda	whiteout_via_lfsr_state
	cmp	#$a9		; At the beginning?
	bne	@loop
@out:	rts
@advance:
	lsr	whiteout_via_lfsr_state
	bcc	@skip
	lda	whiteout_via_lfsr_state
	eor	#$e1
	sta	whiteout_via_lfsr_state
@skip:
	rts
@store:
	lda	whiteout_via_lfsr_state
	tax
	lda	whiteout_colour
	sta	screen4col-1,x
	sta	screen4col+$0100-3,x
	sta	screen4col+$0200-5,x
	sta	screen4col+$0300-8,x
	rts

colourin_via_lfsr:
	lda	#$a9
	sta	whiteout_via_lfsr_state
@loop:	jsr	@advance
	jsr	@store
	lda	whiteout_via_lfsr_state
	cmp	#$a9		; At the beginning?
	beq	@out
	jsr	@advance
	jsr	@store
	lda	whiteout_via_lfsr_state
	cmp	#$a9		; At the beginning?
	beq	@out
	jsr	@advance
	jsr	@store
	jsr	wait_single_frame
	lda	whiteout_via_lfsr_state
	cmp	#$a9		; At the beginning?
	bne	@loop
@out:	rts
@advance:
	lsr	whiteout_via_lfsr_state
	bcc	@skip
	lda	whiteout_via_lfsr_state
	eor	#$e1
	sta	whiteout_via_lfsr_state
@skip:
	rts
@store:
	lda	whiteout_via_lfsr_state
	tax
	lda	imagecolours-1,x
	sta	screen4col-1,x
	lda	imagecolours+$0100-3,x
	sta	screen4col+$0100-3,x
	lda	imagecolours+$0200-5,x
	sta	screen4col+$0200-5,x
	lda	imagecolours+$0300-8,x
	sta	screen4col+$0300-8,x
	rts


	.bss
whiteout_via_lfsr_state:	.res	1

	.code
whiteout_whole_screen:
	lda	#20
	sta	@cnt
@l:	jsr	whiteout_screen
	jsr	wait_single_frame
	dec	@cnt
	bne	@l
	rts
@cnt:	.byte	0


colourin_whole_screen:
	lda	#20
	sta	@cnt
@l:	jsr	colourin_screen
	jsr	wait_single_frame
	dec	@cnt
	bne	@l
	rts
@cnt:	.byte	0


	
fill_screenram:
	ldx	#0
@l:	sta	screen4col,x
	sta	screen4col+$100,x
	sta	screen4col+$200,x
	sta	screen4col+$300-24,x
	dex
	bne	@l
	rts

;;; Fill the colour RAM.
;;; Input: A=colour
;;; Modifies: A/X
fill_colourram:
	ldx	#0
@l:	sta	$d800,x
	sta	$d900,x
	sta	$da00,x
	sta	$db00,x
	dex
	bne	@l
	rts


;;; ca65 -t c64 -I ../includeCC65/ wotahero.s && cl65  wotahero.o wotahero.cfg

	.include	"vicmacros.i"
	.include	"pseudo16.inc"

	sidMuzakInit = $1000
	sidMuzakPlay = $1003

	.import	sidmusic

	.segment "LOADADDR"
	.export __LOADADDR__
__LOADADDR__:	.word $0400

	.zeropage
srcptr:	.word	0
dstptr:	.word	0
srcend:	.word	0
tmpptr:	.word	0

	.segment "STARTUP"
	cld
	cld
	sei
	ldx	#$ff
	txs
	jsr	_main
	jsr	*
	lda	#$37
	sta	$1
	jmp	64738
	.BYTE	"THE 7TH DIVISION"
	.byte $14,$08,$05,$20,$37,$14,$08,$20,$04,$09,$16,$09,$13,$09,$0f,$0e

	.segment "IMAGE"
	.asciiz	"image"


	.data
image_iwatani:
	.incbin	"toru_iwatani.bw.c64"

	.code
_main:
	lda	#$0b
	sta	$d020
	jsr	setupirq
	jsr	init
	jsr	cpyimage
	cli
mainloop:
	sei
	lda	$1		; Store old memory configuration
	pha
	lda	#$35		; I/O on
	sta	$1
	lda	$dc06
	sta	$d020
	pla			; Resotre old configuration.
	sta	$1
	cli
	jsr	mainloop
	rts

irqroutine:
	lda	#$37		; Turn on I/O
	sta	$1
	;; 	inc	$d020
	jsr	$1003
	asl	$d019
	lda	#$30		; Turn to RAM only
	sta	$1
	rti

setupirq:
	lda	#<irqroutine
	sta	$FFFE
	lda	#>irqroutine
	sta	$FFFF
	lda	#$7f
	sta	$dc0d	;disable timer interrupts which can be generated by the two CIA chips
	sta	$dd0d	;the kernal uses such an interrupt to flash the cursor and scan the keyboard,
			;so we better stop it.
	lda	$dc0d	;by reading this two registers we negate any pending CIA irqs.
	lda	$dd0d	;if we don't do this, a pending CIA irq might occur after we finish setting up our irq.
			;we don't want that to happen.
	;; https://www.c64-wiki.com/wiki/Raster_interrupt
	lda	#$7f
	and	$d011		; Set MSB of raster to zero
	sta	$d011
	lda	#50-1		; Top of screen minus one rasterline
	sta	$d012
	;; http://unusedino.de/ec64/technical/project64/mapping_c64.html
	; 53274         $D01A          IRQMASK
	; IRQ Mask Register
	; 
	; Bit 0:  Enable Raster Compare IRQ (1=interrupt enabled)
	; Bit 1:  Enable IRQ to occure when sprite collides with display of
	;   normal
	;         graphics data (1=interrupt enabled)
	; Bit 2:  Enable IRQ to occur when two sprites collide (1=interrupt
	;   enabled)
	; Bit 3:  Enable light pen to trigger an IRQ (1=interrupt enabled)
	; Bits 4-7:  Not used
	lda	#%00000001
	sta	$d01a
	rts

cpyimage:
	P_loadi srcend,image_iwatani+8000
	P_loadi srcptr,image_iwatani
	P_loadi dstptr,$e000
	ldy	#0
l1:	lda	(srcptr),y
	sta	(dstptr),y
;;; 	P_storeb srcptr,dstptr
	P_transfer srcptr,tmpptr
	P_inc	srcptr
	P_inc	dstptr
	P_sub	srcend,tmpptr
	P_branchNZ tmpptr,l1
	P_loadi srcend,image_iwatani+8000+1000
	P_loadi srcptr,image_iwatani+8000
	P_loadi dstptr,$dc00
l2:	lda	(srcptr),y
	sta	(dstptr),y
	;; 	P_storeb srcptr,dstptr
	P_transfer srcptr,tmpptr
	P_inc	srcptr
	P_inc	dstptr
	P_sub	srcend,tmpptr
	P_branchNZ tmpptr,l2
	rts

init:
	SwitchVICBank 3
	SetHiresBitmapMode
	SetBitmapAddress $2000
	SetScreenMemory $1c00
	jsr	sidMuzakInit
	lda	#0
	sta	$dc0f
	lda	#$ff
	sta	$dc05		; TIMAHI
	sta	$dc04		; TIMALO
	sta	$dc07		; TIMBHI
	sta	$dc06		; TIMBLO
	;; http://www.unusedino.de/ec64/technical/project64/mapping_c64.html
; 	56335         $DC0F          CIACRB
;	Control Register B
;	
;	Bit 0:  Start Timer B (1=start, 0=stop)
;	Bit 1:  Select Timer B output on Port B (1=Timer B output appears on
;	        Bit 7 of Port B)
;	Bit 2:  Port B output mode (1=toggle Bit 7, 0=pulse Bit 7 for one
;	        cycle)
;	Bit 3:  Timer B run mode (1=one-shot, 0=continuous)
;	Bit 4:  Force latched value to be loaded to Timer B counter (1=force
;	        load strobe)
;	Bits 5-6:  Timer B input mode
;	           00 = Timer B counts microprocessor cycles
;	           01 = Count signals on CNT line at pin 4 of User Port
;	           10 = Count each time that Timer A counts down to 0
;	           11 = Count Timer A 0's when CNT pulses are also present
;	Bit 7:  Select Time of Day write (0=writing to TOD registers sets
;	        alarm, 1=writing to TOD registers sets clock)
;	
;	Bits 0-3.  This nybble performs the same functions for Timer B that
;	Bits 0-3 of Control Register A perform for Timer A, except that Timer
;	B output on Data Port B appears at Bit 7, and not Bit 6.
;	
;	Bits 5 and 6.  These two bits are used to select what Timer B counts.
;	If both bits are set to 0, Timer B counts the microprocessor machine
;	cycles (which occur at the rate of 1,022,730 cycles per second).  If
;	Bit 6 is set to 0 and Bit 5 is set to 1, Timer B counts pulses on the
;	CNT line, which is connected to pin 4 of the User Port.  If Bit 6 is
;	set to 1 and Bit 5 is set to 0, Timer B counts Timer A underflow
;	pulses, which is to say that it counts the number of times that Timer
;	A counts down to 0.  This is used to link the two numbers into one
;	32-bit timer that can count up to 70 minutes with accuracy to within
;	1/15 second.  Finally, if both bits are set to 1, Timer B counts the
;	number of times that Timer A counts down to 0 and there is a signal on
;	the CNT line (pin 4 of the User Port).
;	
;	Bit 7.  Bit 7 controls what happens when you write to the Time of Day
;	registers.  If this bit is set to 1, writing to the TOD registers sets
;	the ALARM time.  If this bit is cleared to 0, writing to the TOD
;	registers sets the TOD clock.
	lda	#%01010001
	sta	$dc0f
	lda	#$30
	sta	$1
	rts

	;; https://www.c64-wiki.com/wiki/raster_time
; Raster time equals the duration it takes the VIC-II to put a byte of graphic data (=8 pixels/bits) onto the screen and is measured in horizontal lines or CPU cycles.
; 
; Raster time for one horizontal line of graphic (504 pixels including border) equals 63 CPU cycles. The whole graphic screen consists of 312 horizontal lines including the border. In total there are 63 * 312 CPU cycles for one complete screen update/frame, which equals 19656 CPU cycles. Given the C64 CPU clock with 985248 Hertz divided by the 19565 CPU cycles, the result is ~50Hz (the PAL screen standard), not considering the time for screen blanking.


	.data
	.asciiz	"Data Segment"


;;; ca65 -t c64 -I ../includeCC65/ wotahero.s && cl65  wotahero.o wotahero.cfg

	.include	"vicmacros.i"
	.include	"pseudo16.inc"
	.macpack	longbranch
	.macpack	cbm
	.macpack	generic

	sidMuzakInit = $1000
	sidMuzakPlay = $1003

	.exportzp	tmpptr
	.export _main
	.export	framecounter
	.export ciatimercopy

	.import	sidmusic
	.import unpucrunch

	.segment "LOADADDR"
	.export __LOADADDR__
__LOADADDR__:	.word $0400

	.zeropage
srcptr:	.word	0
dstptr:	.word	0
srcend:	.word	0
tmpptr:	.word	0
counter16:	.word 0
irqXsave:	.byte 0
irqYsave:	.byte 0

	.segment "IMAGE"
screen0:
	.res	1024
screen1:
	.res	1024
sprites:
	.res	64*16		; 1024
imagecolours:
	.res	1024


	.bss
framecounter:	.word 0
ciatimercopy:	.dword 0

	.data
image_iwatani:
	.incbin	"toru_iwatani.bw.c64"
image_cr_story00:
	.incbin	"story.00.pucr",2
image_cr_iwatani:
	.incbin	"toru_iwatani.bw.pucr",2


	.code
_main:
	lda	#$0b
	sta	$d020
	jsr	setupirq
	jsr	init
	jsr	cpyimage
	lda	#0
	sta	framecounter
	sta	framecounter+1
	cli
mainloop:
	sei
	lda	$1		; Store old memory configuration
	pha
	lda	#$35		; I/O on
	sta	$1
	inc	$d020
	pla			; Resotre old configuration.
	sta	$1
	cli
	;; 
	lda	#$1
	jsr	wait_for_framecounter
	;inc	imagecolours
	;inc	$e000
	;;
	lda	#$2
	jsr	wait_for_framecounter
	ldx	#>image_cr_story00
	ldy	#<image_cr_story00
	jsr	unpucrunch
	nop
	ldy	#0
	;;
	P_loadi	srcptr,$d400+8000+1000
	P_loadi	dstptr,$d000+1000
	P_loadi counter16,1000+1
imageloop2:
	lda	(srcptr),y
	sta	(dstptr),y
	P_dec	srcptr
	P_dec	dstptr
	P_dec	counter16
	P_branchNZ counter16,imageloop2
	;; 
	P_loadi	srcptr,$d400+8000
	P_loadi	dstptr,$e000+8000
	P_loadi counter16,8000+1
imageloop1:
	lda	(srcptr),y
	sta	(dstptr),y
	P_dec	srcptr
	P_dec	dstptr
	P_dec	counter16
	P_branchNZ counter16,imageloop1
	;;
	P_loadi	srcptr,$d000+1000
	P_loadi	dstptr,$dc00+1000
	P_loadi counter16,1000+1
imageloop3:
	lda	(srcptr),y
	sta	(dstptr),y
	P_dec	srcptr
	P_dec	dstptr
	P_dec	counter16
	P_branchNZ counter16,imageloop3
	nop
	;; 
	lda	#$34		; End after n*256 frames.
	cmp	framecounter+1
	jne	mainloop
	rts

;;; Wait until the framecounter reaches a value, clear to zero afterwards. Only high byte!
;;; Input:
;;;	A: High value to wait for
;;; Modifies: A
;;; Returns: A=0
wait_for_framecounter:
@l1:	cmp	framecounter+1
	bne	@l1
	lda	#0
	sta	framecounter+1
	rts

irqroutine:
	pha
	stx	irqXsave
	sty	irqYsave
	lda	#$37		; Turn on I/O
	sta	$1
	;; 	inc	$d020
	jsr	$1003
	P_inc	framecounter	; Advance frame counter.
	;; Copy the current timer information.
	ldx	#3
@l1:	lda	$dc04,x
	sta	ciatimercopy,x
	dex
	bpl	@l1
	asl	$d019
	lda	#$30		; Turn to RAM only
	sta	$1
	ldy	irqYsave
	ldx	irqXsave
	pla
	rti

setupirq:
	lda	#<irqroutine
	sta	$FFFE
	lda	#>irqroutine
	sta	$FFFF
	lda	#$7f
	sta	$dc0d	;disable timer interrupts which can be generated by the two CIA chips
	sta	$dd0d	;the kernal uses such an interrupt to flash the cursor and scan the keyboard,
			;so we better stop it.
	lda	$dc0d	;by reading this two registers we negate any pending CIA irqs.
	lda	$dd0d	;if we don't do this, a pending CIA irq might occur after we finish setting up our irq.
			;we don't want that to happen.
	;; https://www.c64-wiki.com/wiki/Raster_interrupt
	lda	#$7f
	and	$d011		; Set MSB of raster to zero
	sta	$d011
	lda	#50-1		; Top of screen minus one rasterline
	sta	$d012
	;; http://unusedino.de/ec64/technical/project64/mapping_c64.html
	; 53274         $D01A          IRQMASK
	; IRQ Mask Register
	; 
	; Bit 0:  Enable Raster Compare IRQ (1=interrupt enabled)
	; Bit 1:  Enable IRQ to occure when sprite collides with display of
	;   normal
	;         graphics data (1=interrupt enabled)
	; Bit 2:  Enable IRQ to occur when two sprites collide (1=interrupt
	;   enabled)
	; Bit 3:  Enable light pen to trigger an IRQ (1=interrupt enabled)
	; Bits 4-7:  Not used
	lda	#%00000001
	sta	$d01a
	rts

cpyimage:
	P_loadi srcend,image_iwatani+8000
	P_loadi srcptr,image_iwatani
	P_loadi dstptr,$e000
	ldy	#0
l1:	lda	(srcptr),y
	sta	(dstptr),y
;;; 	P_storeb srcptr,dstptr
	P_transfer srcptr,tmpptr
	P_inc	srcptr
	P_inc	dstptr
	P_sub	srcend,tmpptr
	P_branchNZ tmpptr,l1
	P_loadi srcend,image_iwatani+8000+1000
	P_loadi srcptr,image_iwatani+8000
	P_loadi dstptr,$dc00
l2:	lda	(srcptr),y
	sta	(dstptr),y
	;; 	P_storeb srcptr,dstptr
	P_transfer srcptr,tmpptr
	P_inc	srcptr
	P_inc	dstptr
	P_sub	srcend,tmpptr
	P_branchNZ tmpptr,l2
	rts

init:
	SwitchVICBank 3
	SetHiresBitmapMode
	SetBitmapAddress $2000
	SetScreenMemory $1c00
	jsr	sidMuzakInit
	lda	#0
	sta	$dc0f
	lda	#$ff
	sta	$dc05		; TIMAHI
	sta	$dc04		; TIMALO
	sta	$dc07		; TIMBHI
	sta	$dc06		; TIMBLO
	;; http://www.unusedino.de/ec64/technical/project64/mapping_c64.html
; 	56335         $DC0F          CIACRB
;	Control Register B
;	
;	Bit 0:  Start Timer B (1=start, 0=stop)
;	Bit 1:  Select Timer B output on Port B (1=Timer B output appears on
;	        Bit 7 of Port B)
;	Bit 2:  Port B output mode (1=toggle Bit 7, 0=pulse Bit 7 for one
;	        cycle)
;	Bit 3:  Timer B run mode (1=one-shot, 0=continuous)
;	Bit 4:  Force latched value to be loaded to Timer B counter (1=force
;	        load strobe)
;	Bits 5-6:  Timer B input mode
;	           00 = Timer B counts microprocessor cycles
;	           01 = Count signals on CNT line at pin 4 of User Port
;	           10 = Count each time that Timer A counts down to 0
;	           11 = Count Timer A 0's when CNT pulses are also present
;	Bit 7:  Select Time of Day write (0=writing to TOD registers sets
;	        alarm, 1=writing to TOD registers sets clock)
;	
;	Bits 0-3.  This nybble performs the same functions for Timer B that
;	Bits 0-3 of Control Register A perform for Timer A, except that Timer
;	B output on Data Port B appears at Bit 7, and not Bit 6.
;	
;	Bits 5 and 6.  These two bits are used to select what Timer B counts.
;	If both bits are set to 0, Timer B counts the microprocessor machine
;	cycles (which occur at the rate of 1,022,730 cycles per second).  If
;	Bit 6 is set to 0 and Bit 5 is set to 1, Timer B counts pulses on the
;	CNT line, which is connected to pin 4 of the User Port.  If Bit 6 is
;	set to 1 and Bit 5 is set to 0, Timer B counts Timer A underflow
;	pulses, which is to say that it counts the number of times that Timer
;	A counts down to 0.  This is used to link the two numbers into one
;	32-bit timer that can count up to 70 minutes with accuracy to within
;	1/15 second.  Finally, if both bits are set to 1, Timer B counts the
;	number of times that Timer A counts down to 0 and there is a signal on
;	the CNT line (pin 4 of the User Port).
;	
;	Bit 7.  Bit 7 controls what happens when you write to the Time of Day
;	registers.  If this bit is set to 1, writing to the TOD registers sets
;	the ALARM time.  If this bit is cleared to 0, writing to the TOD
;	registers sets the TOD clock.
	lda	#%01010001
	sta	$dc0f
	lda	#$30
	sta	$1
	rts

	;; https://www.c64-wiki.com/wiki/raster_time
; Raster time equals the duration it takes the VIC-II to put a byte of graphic data (=8 pixels/bits) onto the screen and is measured in horizontal lines or CPU cycles.
; 
; Raster time for one horizontal line of graphic (504 pixels including border) equals 63 CPU cycles. The whole graphic screen consists of 312 horizontal lines including the border. In total there are 63 * 312 CPU cycles for one complete screen update/frame, which equals 19656 CPU cycles. Given the C64 CPU clock with 985248 Hertz divided by the 19565 CPU cycles, the result is ~50Hz (the PAL screen standard), not considering the time for screen blanking.


	.data
	.asciiz	"Data Segment"
